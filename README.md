# lab2
Шаломина Александра ПМ-2401. Вариант: 29
## Cодержание

1. [Отчет по лабораторной работе №](#отчет-по-лабораторной-работе--n)
2. [Критерии оценивания](#критерии-оценивания)

## Отчет по лабораторной работе № 1

#### № группы: `ПМ-2401`
#### Выполнил: `Шаломина Адександра Тимофеевна`
#### Вариант: `29`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

Напишите программу на Java, которая выполняет следующие действия
с трёхмерным массивом целых чисел:
1.  Считывает с консоли размеры массива X, Y и Z, затем элементы
   массива размером X × Y × Z.
2.  Сортирует каждый слой массива (по координатам Y и Z) по возрастанию суммы элементов в слое. Если суммы равны, сортирует
   по количеству чётных чисел в слое. 
3.  Находит и выводит общую сумму всех элементов массива.
4.  Выводит элементы массива, представляя их в виде срезов по оси
   Z.
5.  Заменяет все отрицательные числа в массиве на их модули и выводит обновлённый массив.



- Нужно создать и инициализировать трехмерный массив.
- Для удобства подсчета я создаю еще один двумерный массив длинной первого аргумента х ( т.к сортировать нужно по оси у и z ) и второго аргумента 3 ( для хранения суммы слоя, количества четных элементов, порядкового номера слоя ).
- Инициализация нового массива.
- Подсчет суммы всех элементов массива и вывод.
- Сортировка нового массива методом пузырька по первому элементу каждой строчки, при равенстве этого элемента, сортировка идет по второму элементу( в задании не указано по убыванию или возрастанию нужно сортировать, поэтому я сортирую по возрастанию). 
- Создание еще одного массива для записи финального результата
- Инициализация финального массива ( в виде срезов по оси х ).
- вывод массива в виде среза по оси z.
- замена всех чисел массива на их модули и вывод массива по оси z.
### 2. Входные и выходные данные
На вход программе подаются 3 целых числа (т.к. размеры массива не могут принимать дробные или иррациональные значения), верхняя граница не обозначена, нижняя граница 1, т.к. массив не может иметь отрицательную или нулевую длину.
Потом вводится еще x * y * z целых значений (в этом случае тип данных определен по условию и не имеет верхней и нижней границы). 

|                                  | Тип         | min значение | max значение |
|----------------------------------|-------------|--------------|----|
| x (Число 1)                      | Целое число | 1            | +2^31 |
| y (Число 2)                      | Целое число | 1            | +2^31   |
| z (Число 2)                      | Целое число | 1            |  +2^31  |
| набор чисел (размера x * y * z)  | Целые числа | -2^31        | +2^31   |

#### Данные на выход
На выход необходимо вывести сумму всех элементов массива (данное значение не имеет верхней и нижней границы),
срезы отсортированного массива по оси z (в виде z штук таблиц целых чисел) (данные значение не имеет верхней и нижней границы),
срезы отсортированного массива по оси z, состоящие из модулей чисел изначального массива (в виде z штук таблиц целых чисел) (данные значение не имеет верхней границы, но имеет нижнюю - 0),



|                 | Тип         | min значение | max значение |
|-----------------|-------------|--------------|--------------|
| Число 1 (сумма) | Целое число | -2^31        | +2^31            |
| массив          | Целые числа | -2^31        | +2^31            |
| массив          | Целые числа | 0            | +2^31            |

### 3. Выбор структуры данных

Программа получает на вход 3 целых различных числа, для их хранения можно выделить 3 переменные (`x`,`y`,`z`), типа `int`,
и набор целых чисел, которые можно хранить в массиве размером x * y * z. 


|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| x (Число 1) | `x`                 | `int`        |
| y (Число 2) | `y`                 | `int`        | 
| z (Число 1) | `z`                 | `int`        |
| массив      | `masiv`             | `int`        |

Для вывода результата надо создать целочисленную переменную для общей суммы `osum`.
Для вывода финального массива нужно создать новый массив `masiv2` и работать уже с ним.


|        | название переменной | Тип (в Java) | 
|--------|---------------------|--------------|
| сумма  | `osum`              | `int`        |
| массив | `masiv2`            | `int`        |


### 4. Алгоритм

1. **Ввод данных:**  
   Программа считывает четыре целых числа, обозначенные как `x`,`y`,`z`.
   Создается трехмерный массив размером [x][y][z].
   С помощью цикла for массив инициализируется элементами, вводимыми с клавиатуры.
2. **Сортировка:**  
   1. создается дополнительный двумерный массив для сортировки слоев по оси х. Первый аргумент которого равен числу слоев т.е х, а второй 3 - для хранения суммы в слое, количества четных чисел и порядковый номер слоя. 
   2. теперь с помощью цикла for происходит инициализация дополнительного массива. для этого на каждом шаге при прохождении по значениям х изначального массива создается переменная `sum` и переменная `k`. теперь при прохождении внутри этого цикла по значениям y и z мы прибавляем к `sum` значение каждого элемента массива, и с помощью условного оператора if роверяем элемент на четность, если он четный прибавляем  еденицу к `k`.
   3. на каждом шаге при прохождении по значениям х в первое значение второго аргумента дополнительного массива записывается `sum`, во второе `k`, в третье - номер слоя (индекс выполняемого шага).
   4. создается финальный трехмерный массив, идентичный по размерам первому ([x][y][z]). инициализация его происходит с помощью цикла for : при прохождении дополнительного массива по х (т.е по слоям) каждому слою присваивается значение слоя изначального массива с порядковым номер равным значению третьего элемента второго аргумента дополнительного массива того же слоя     
3. **Подсчет общей суммы всех элементов**
  - создается переменная `osum`, она с помощью цикла for прибавляет сумму каждого слоя при проходе по х в дополнительном массиве
  - после выводится на экран
4. **Вывод результата:**  
   1. сначала отсортированный массив выводится в виде срезов по оси z с помощью цикла for.
   2. потом с помощью for каждый элемент заменяется на его модуль(хоть в задании и требуется брать по модулю только отрицательные числа, но любое неотрицательное число равно его модулю, поэтому, для упрощения кода можно взять по модулю каждое число).
   3. после этого массив еще раз выводится (как в пункте 1).

### 5. Программа

```java
import java.io.IOException;
import java.io.PrintStream;
import java.util.Scanner;
public class sasha {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) throws IOException {
        int x = in.nextInt();
        int y = in.nextInt();
        int z = in.nextInt();
        int [][][] masiv = new int [x][y][z];
        for (int i=0; i<masiv.length;i++){
            for (int j=0; j<masiv[i].length;j++){
                for (int p=0;p<masiv[i][j].length;p++){
                    masiv[i][j][p]=in.nextInt();
                }
            }
        }// инициализация

        int [][] masiv1 = new int [x][3];// массив для хранения данных

        for (int i=0; i<masiv.length;i++){
            int sum=0;
            int k = 0;
            for (int j=0; j<masiv[i].length;j++){
                for (int p=0;p<masiv[i][j].length;p++){
                    sum+=masiv[i][j][p];
                    if (masiv[i][j][p]%2==0)
                        k++;
                }
            }
            masiv1[i][0]=sum;
            masiv1[i][1]=k;
            masiv1[i][2]=i;
        }// инициализация нового массива

        for (int i=masiv1.length-1;i>0;i--){
            for (int j =0; j<i;j++){
                if (masiv1[j][0]>masiv1[j+1][0]){
                    int [] t = masiv1[j];
                    masiv1[j]=masiv1[j+1];
                    masiv1[j+1]=t;}
                if (masiv1[j][0]==masiv1[j+1][0]){
                    if (masiv1[j][1]>masiv1[j+1][1]){
                        int [] t = masiv1[j];
                        masiv1[j]=masiv1[j+1];
                        masiv1[j+1]=t;}
                }
            }

        }// сортировка нового массива

        int [][][] masiv2 = new int [x][y][z];//создание финального отсортированного массива

        for (int i= 0;i<masiv1.length;i++)
            masiv2[i]=masiv[masiv1[i][2]];//инициализвция отсортированного массива

        int osum=0;// переменная для суммы всех элементов
        for (int i=0; i<masiv1.length;i++)
            osum+=masiv1[i][0]; // подсчет суммы всех элементов массива
        out.println("\nсумма всех элементов:");
        out.println(osum);//вывод суммы всех элементов

        out.println("отосортированный масив в виде среза по оси z");

        for (int i=0; i<z;i++) {
            for (int j = 0; j < x; j++) {
                for (int p = 0; p < y; p++) {
                    out.print(masiv2[j][p][i]+" ");
                }
                out.println();
            }
            out.println();
        }// вывод массива в виде среза по оси z

        for (int i= 0; i<x;i++){
            for (int j=0;j<y;j++){
                for (int p=0;p<z;p++){
                    masiv2[i][j][p]=Math.abs(masiv2[i][j][p]);
                }
            }
        } //замена отрицательных значений на их модуль(т.к значение неотрицательных значений и их модуль равны, то можно просто каждый элемент заменить на его модуль)

        out.println("финальный массив:");

        for (int i=0; i<z;i++) {
            for (int j = 0; j < x; j++) {
                for (int p = 0; p < y; p++) {
                    out.print(masiv2[j][p][i]+" ");
                }
                out.println();
            }
            out.println();
        }// вывод финального массива
    }
}
```
### 5. Математическая модель

 В своей программе я не использую никаких формул, кроме поиска модуля

### 6. Анализ правильности решения

1. Тест обычного примера 

   - Input:
       ```
        4 3 2 
        1 2 3 4 5 6 6 7 8 9 9 -2 -6 -7 -3 -4 -5 -2 2 3 4 5 6 -9
       ```

- Output:
    ```
    сумма всех элементов:
    42
    отосортированный масив в виде среза по оси z
    -6 -3 -5
    2 4 6
    1 3 5
    6 8 9
    
    -7 -4 -2
    3 5 -9
    2 4 6
    7 9 -2
    
    финальный массив:
    6 3 5
    2 4 6
    1 3 5
    6 8 9
    
    7 4 2
    3 5 9
    2 4 6
    7 9 2


    ```

2. Тест на проверку случая со слоями с одинаковыми суммами

- Input:
    ```
    4 3 2
    16 2 4 4 5 6 6 7 8 9 9 -2 -6 -7 -3 -4 -5 -2 2 3 4 5 6 -9
    ```

- Output:
    ```
    сумма всех элементов:
    58
    отосортированный масив в виде среза по оси z
    -6 -3 -5
    2 4 6
    6 8 9
    16 4 5
    
    -7 -4 -2
    3 5 -9
    7 9 -2
    2 4 6
    
    финальный массив:
    6 3 5
    2 4 6
    6 8 9
    16 4 5
    
    7 4 2
    3 5 9
    7 9 2
    2 4 6

    ```

# Критерии оценивания

Обратите внимание на то, что лабораторная работа должна быть выложена в отдельный репозиторий с названием LabN (N -
Номер лабы). В репозитории должно быть минимум 2 файла (README.md - отчет, Main.java - код лабы)

| **Критерий**                                                                                                                                                                           | **Баллы**       |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
| **Корректность программы**                                                                                                                                                             | **0** - **40**  |
| - Программа полностью выполняет задачу                                                                                                                                                 | 15              |
| - Нет ошибок выполнения                                                                                                                                                                | 10              |
| - Учтены все ограничения                                                                                                                                                               | 5               |
| - Правильное поведение в "крайних" случаях                                                                                                                                             | 10              |
|                                                                                                                                                                                        |                 |
| **Оптимизация кода**                                                                                                                                                                   | **0** - **20**  |
| - Эффективные алгоритмы                                                                                                                                                                | 10              |
| - Избежание избыточности и повторов                                                                                                                                                    | 5               |
| - Разумность использования структур данных                                                                                                                                             | 5               |
|                                                                                                                                                                                        |                 |
| **Читабельность и стиль кода**                                                                                                                                                         | **0** - **20**  |
| - Соблюдение стандартов форматирования                                                                                                                                                 | 5               |
| - Наличие комментариев, в полном объеме поясняющих написанный код                                                                                                                      | 10              |
| - Понятные имена переменных и функций                                                                                                                                                  | 5               |
|                                                                                                                                                                                        |                 |
| **Оформление отчета**                                                                                                                                                                  | **0** - **20**  |
| - Соблюдение структуры отчета                                                                                                                                                          | 5               |
| - Отчет загружен на GitHub в репозиторий с названием LabN (N - номер лабораторной работы), отчет в формате Markdown с названием README.md, также есть файл Main.java с кодом программы | Обязательно     |
| - Четкое описание алгоритма (блок-схема если нужна)                                                                                                                                    | 5               |
| - Полнота покрытия тестами всех случаев                                                                                                                                                | 5               |
| - Обоснования использования алгоритма, структур данных                                                                                                                                 | 5               |
|                                                                                                                                                                                        |                 |
| **Общая сумма**                                                                                                                                                                        | **0** - **100** |


